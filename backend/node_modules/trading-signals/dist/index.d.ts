declare class NotEnoughDataError extends Error {
    constructor(requiredAmount: number);
}

type Nullable<Result> = Result | null;
interface Indicator<Result = number, Input = number> {
    isStable: boolean;
    add(input: Input): Nullable<Result>;
    getRequiredInputs(): number;
    getResult(): Nullable<Result>;
    getResultOrThrow(): Result;
    replace(input: Input): Nullable<Result>;
    update(input: Input, replace: boolean): Nullable<Result>;
    updates(input: Input[], replace: boolean): Nullable<Result>[];
}
declare abstract class TechnicalIndicator<Result, Input> implements Indicator<Result, Input> {
    protected result: Result | undefined;
    abstract getRequiredInputs(): number;
    getResult(): (Result & {}) | null;
    getResultOrThrow(): Result & ({} | null);
    get isStable(): boolean;
    add(input: Input): Result | null;
    replace(input: Input): Result | null;
    abstract update(input: Input, replace: boolean): Result | null;
    updates(inputs: readonly Input[], replace?: boolean): (Result | null)[];
}
declare abstract class BaseIndicatorSeries<Result, Input> extends TechnicalIndicator<Result, Input> {
    protected previousResult?: Result;
    protected abstract setResult(value: Result, replace: boolean): Result;
}
declare abstract class IndicatorSeries<Input = number> extends BaseIndicatorSeries<number, Input> {
    protected setResult(value: number, replace: boolean): number;
}

declare class TDS extends IndicatorSeries {
    private readonly closes;
    private setupCount;
    private setupDirection;
    getRequiredInputs(): number;
    update(close: number, replace: boolean): number | null;
}

declare abstract class MovingAverage extends IndicatorSeries {
    readonly interval: number;
    constructor(interval: number);
}

declare class EMA extends MovingAverage {
    readonly interval: number;
    private pricesCounter;
    private readonly weightFactor;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number;
    getResultOrThrow(): number;
    get isStable(): boolean;
}

declare class RMA extends MovingAverage {
    readonly interval: number;
    private pricesCounter;
    private readonly weightFactor;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number;
    getResultOrThrow(): number;
    get isStable(): boolean;
}

declare class SMA extends MovingAverage {
    readonly prices: number[];
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class WMA extends MovingAverage {
    readonly interval: number;
    readonly prices: number[];
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class WSMA extends IndicatorSeries {
    readonly interval: number;
    private readonly indicator;
    private readonly smoothingFactor;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

type MovingAverageTypes = typeof EMA | typeof RMA | typeof SMA | typeof WMA | typeof WSMA;

type HighLow<T = number> = {
    high: T;
    low: T;
};
type HighLowClose<T = number> = HighLow<T> & {
    close: T;
};
type OpenHighLowClose<T = number> = HighLowClose<T> & {
    open: T;
};
type OpenHighLowCloseVolume<T = number> = OpenHighLowClose<T> & {
    volume: T;
};
type HighLowCloseVolume<T = number> = Omit<OpenHighLowCloseVolume<T>, 'open'>;

declare class AO extends IndicatorSeries<HighLow<number>> {
    readonly shortInterval: number;
    readonly longInterval: number;
    readonly long: MovingAverage;
    readonly short: MovingAverage;
    constructor(shortInterval: number, longInterval: number, SmoothingIndicator?: MovingAverageTypes);
    getRequiredInputs(): number;
    update({ low, high }: HighLow<number>, replace: boolean): number | null;
}

declare class MOM extends IndicatorSeries {
    readonly interval: number;
    private readonly history;
    private readonly historyLength;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(value: number, replace: boolean): number | null;
}

declare class AC extends IndicatorSeries<HighLow<number>> {
    readonly shortAO: number;
    readonly longAO: number;
    readonly signalInterval: number;
    readonly ao: AO;
    readonly momentum: MOM;
    readonly signal: SMA;
    constructor(shortAO: number, longAO: number, signalInterval: number);
    getRequiredInputs(): number;
    update(input: HighLow<number>, replace: boolean): number | null;
}

declare class CCI extends IndicatorSeries<HighLowClose<number>> {
    readonly interval: number;
    private readonly sma;
    private readonly typicalPrices;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
    private cacheTypicalPrice;
}

declare class CG extends IndicatorSeries {
    readonly interval: number;
    readonly signalInterval: number;
    signal: SMA;
    readonly prices: number[];
    get isStable(): boolean;
    constructor(interval: number, signalInterval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class DEMA extends IndicatorSeries {
    readonly interval: number;
    private readonly inner;
    private readonly outer;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number;
    get isStable(): boolean;
}

type MACDResult = {
    histogram: number;
    macd: number;
    signal: number;
};
declare class MACD extends TechnicalIndicator<MACDResult, number> {
    readonly short: EMA | DEMA;
    readonly long: EMA | DEMA;
    readonly signal: EMA | DEMA;
    readonly prices: number[];
    constructor(short: EMA | DEMA, long: EMA | DEMA, signal: EMA | DEMA);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): {
        histogram: number;
        macd: number;
        signal: number;
    } | null;
}

declare class OBV extends IndicatorSeries<OpenHighLowCloseVolume<number>> {
    readonly candles: OpenHighLowCloseVolume<number>[];
    getRequiredInputs(): number;
    update(candle: OpenHighLowCloseVolume<number>, replace: boolean): number | null;
}

declare class REI extends IndicatorSeries<HighLowClose<number>> {
    readonly interval: number;
    private readonly highs;
    private readonly lows;
    private readonly closes;
    constructor(interval: number);
    getRequiredInputs(): number;
    private calculateN;
    private calculateM;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
}

declare class ROC extends IndicatorSeries {
    readonly interval: number;
    readonly prices: number[];
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class RSI extends IndicatorSeries {
    readonly interval: number;
    private readonly previousPrices;
    private readonly avgGain;
    private readonly avgLoss;
    private readonly maxValue;
    constructor(interval: number, SmoothingIndicator?: MovingAverageTypes);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

interface StochasticResult {
    stochD: number;
    stochK: number;
}
declare class StochasticOscillator extends TechnicalIndicator<StochasticResult, HighLowClose<number>> {
    n: number;
    m: number;
    p: number;
    readonly candles: HighLowClose<number>[];
    private readonly periodM;
    private readonly periodP;
    constructor(n: number, m: number, p: number);
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): {
        stochD: number;
        stochK: number;
    } | null;
}

declare class StochasticRSI extends IndicatorSeries {
    readonly interval: number;
    readonly smoothing: {
        readonly k: MovingAverage;
        readonly d: MovingAverage;
    };
    private readonly period;
    private readonly rsi;
    constructor(interval: number, SmoothingRSI?: MovingAverageTypes, smoothing?: {
        readonly k: MovingAverage;
        readonly d: MovingAverage;
    });
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class WilliamsR extends TechnicalIndicator<number, HighLowClose<number>> {
    readonly interval: number;
    readonly candles: HighLowClose<number>[];
    constructor(interval: number);
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
}

declare class ADX extends IndicatorSeries<HighLowClose<number>> {
    readonly interval: number;
    private readonly dx;
    private readonly smoothed;
    constructor(interval: number, SmoothingIndicator?: MovingAverageTypes);
    get mdi(): number | void;
    get pdi(): number | void;
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
}

interface DMAResult {
    long: number;
    short: number;
}
declare class DMA extends TechnicalIndicator<DMAResult, number> {
    readonly short: MovingAverage;
    readonly long: MovingAverage;
    constructor(short: number, long: number, SmoothingIndicator?: MovingAverageTypes);
    get isStable(): boolean;
    getRequiredInputs(): number;
    update(price: number, replace: boolean): {
        long: number;
        short: number;
    } | null;
}

declare class DX extends IndicatorSeries<HighLowClose<number>> {
    readonly interval: number;
    private readonly movesUp;
    private readonly movesDown;
    private previousCandle?;
    private secondLastCandle?;
    private readonly atr;
    mdi?: number;
    pdi?: number;
    constructor(interval: number, SmoothingIndicator?: MovingAverageTypes);
    private updateState;
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
}

type LinearRegressionResult = {
    prediction: number;
    slope: number;
    intercept: number;
};
declare class LinearRegression extends TechnicalIndicator<LinearRegressionResult, number> {
    readonly interval: number;
    readonly prices: number[];
    constructor(interval: number);
    getRequiredInputs(): number;
    private calculateRegression;
    update(price: number, replace: boolean): LinearRegressionResult | null;
    get isStable(): boolean;
}

type PSARConfig = {
    accelerationStep: number;
    accelerationMax: number;
};
declare class PSAR extends IndicatorSeries<HighLow<number>> {
    private readonly accelerationStep;
    private readonly accelerationMax;
    private acceleration;
    private extreme;
    private lastSar;
    private isLong;
    private previousCandle;
    private prePreviousCandle;
    constructor(config: PSARConfig);
    get isStable(): boolean;
    getRequiredInputs(): number;
    update(candle: HighLow<number>, replace: boolean): number | null;
    getResultOrThrow(): number;
}

declare class SMA15 extends MovingAverage {
    readonly prices: number[];
    private static readonly WEIGHTS;
    private static readonly WEIGHT_SUM;
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class VWAP extends IndicatorSeries<HighLowCloseVolume<number>> {
    private cumulativeTypicalPriceVolume;
    private cumulativeVolume;
    private lastCandle;
    constructor();
    private calculateTypicalPriceVolume;
    getRequiredInputs(): number;
    update(candle: HighLowCloseVolume<number>, replace: boolean): number | null;
}

type ZigZagConfig = {
    deviation: number;
};
declare class ZigZag extends IndicatorSeries<HighLow> {
    private readonly deviation;
    private isUp;
    private highestExtreme;
    private lowestExtreme;
    constructor(config: ZigZagConfig);
    getRequiredInputs(): number;
    update(candle: HighLow<number>, replace: boolean): number | null;
}

interface BandsResult {
    lower: number;
    middle: number;
    upper: number;
}

interface PeriodResult {
    highest: number;
    lowest: number;
}
declare class Period extends TechnicalIndicator<PeriodResult, number> {
    readonly interval: number;
    values: number[];
    private _highest?;
    private _lowest?;
    get highest(): number | undefined;
    get lowest(): number | undefined;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(value: number, replace: boolean): {
        highest: number;
        lowest: number;
    } | null;
}

declare function getAverage(values: number[]): number;

type GridConfig = {
    lower: number;
    upper: number;
    levels: number;
    spacing: 'arithmetic' | 'geometric';
    tickSize?: number;
};
declare function getGrid({ lower, upper, levels, tickSize, spacing }: GridConfig): number[];

declare function getMaximum(values: number[]): number;

declare function getMedian(values: number[]): number;

declare function getMinimum(values: number[]): number;

declare function getQuartile(values: number[], q: 0.25 | 0.5 | 0.75): number;

declare function getStandardDeviation(values: number[], average?: number): number;

type Streak = {
    length: number;
    percentage: number;
};
declare function getStreaks(prices: number[], keepSide: 'up' | 'down'): Streak[];

declare function isMonday(timezone: string, date?: Date): boolean;
declare function isTuesday(timezone: string, date?: Date): boolean;
declare function isWednesday(timezone: string, date?: Date): boolean;
declare function isThursday(timezone: string, date?: Date): boolean;
declare function isFriday(timezone: string, date?: Date): boolean;
declare function isSaturday(timezone: string, date?: Date): boolean;
declare function isSunday(timezone: string, date?: Date): boolean;

declare function pushUpdate<T>(array: T[], replace: boolean, item: T, maxLength: number): T | null | undefined;

declare class AccelerationBands extends TechnicalIndicator<BandsResult, HighLowClose<number>> {
    readonly interval: number;
    readonly width: number;
    private readonly lowerBand;
    private readonly middleBand;
    private readonly upperBand;
    constructor(interval: number, width: number, SmoothingIndicator?: MovingAverageTypes);
    getRequiredInputs(): number;
    update({ high, low, close }: HighLowClose<number>, replace: boolean): {
        lower: number;
        middle: number;
        upper: number;
    } | null;
    get isStable(): boolean;
}

declare class ATR extends IndicatorSeries<HighLowClose<number>> {
    readonly interval: number;
    private readonly tr;
    private readonly smoothing;
    constructor(interval: number, SmoothingIndicator?: MovingAverageTypes);
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number | null;
}

declare class BollingerBands extends TechnicalIndicator<BandsResult, number> {
    readonly interval: number;
    readonly deviationMultiplier: number;
    readonly prices: number[];
    constructor(interval: number, deviationMultiplier?: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): {
        lower: number;
        middle: number;
        upper: number;
    } | null;
}

declare class BollingerBandsWidth extends IndicatorSeries {
    readonly bollingerBands: BollingerBands;
    constructor(bollingerBands: BollingerBands);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
}

declare class IQR extends IndicatorSeries {
    readonly interval: number;
    private readonly values;
    constructor(interval: number);
    getRequiredInputs(): number;
    update(value: number, replace: boolean): number | null;
}

declare class MAD extends IndicatorSeries {
    readonly interval: number;
    readonly prices: number[];
    constructor(interval: number);
    getRequiredInputs(): number;
    update(price: number, replace: boolean): number | null;
    static getResultFromBatch(prices: number[], average?: number): number;
}

declare class TR extends IndicatorSeries<HighLowClose<number>> {
    private previousCandle?;
    private twoPreviousCandle?;
    getRequiredInputs(): number;
    update(candle: HighLowClose<number>, replace: boolean): number;
}

export { AC, ADX, AO, ATR, AccelerationBands, type BandsResult, BaseIndicatorSeries, BollingerBands, BollingerBandsWidth, CCI, CG, DEMA, DMA, type DMAResult, DX, EMA, type GridConfig, type HighLow, type HighLowClose, type HighLowCloseVolume, IQR, IndicatorSeries, LinearRegression, type LinearRegressionResult, MACD, type MACDResult, MAD, MOM, NotEnoughDataError, OBV, type OpenHighLowClose, type OpenHighLowCloseVolume, PSAR, type PSARConfig, Period, type PeriodResult, REI, RMA, ROC, RSI, SMA, SMA15, StochasticOscillator, StochasticRSI, type StochasticResult, type Streak, TDS, TR, TechnicalIndicator, VWAP, WMA, WSMA, WilliamsR, ZigZag, type ZigZagConfig, getAverage, getGrid, getMaximum, getMedian, getMinimum, getQuartile, getStandardDeviation, getStreaks, isFriday, isMonday, isSaturday, isSunday, isThursday, isTuesday, isWednesday, pushUpdate };
