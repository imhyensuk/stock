"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AC: () => AC,
  ADX: () => ADX,
  AO: () => AO,
  ATR: () => ATR,
  AccelerationBands: () => AccelerationBands,
  BaseIndicatorSeries: () => BaseIndicatorSeries,
  BollingerBands: () => BollingerBands,
  BollingerBandsWidth: () => BollingerBandsWidth,
  CCI: () => CCI,
  CG: () => CG,
  DEMA: () => DEMA,
  DMA: () => DMA,
  DX: () => DX,
  EMA: () => EMA,
  IQR: () => IQR,
  IndicatorSeries: () => IndicatorSeries,
  LinearRegression: () => LinearRegression,
  MACD: () => MACD,
  MAD: () => MAD,
  MOM: () => MOM,
  NotEnoughDataError: () => NotEnoughDataError,
  OBV: () => OBV,
  PSAR: () => PSAR,
  Period: () => Period,
  REI: () => REI,
  RMA: () => RMA,
  ROC: () => ROC,
  RSI: () => RSI,
  SMA: () => SMA,
  SMA15: () => SMA15,
  StochasticOscillator: () => StochasticOscillator,
  StochasticRSI: () => StochasticRSI,
  TDS: () => TDS,
  TR: () => TR,
  TechnicalIndicator: () => TechnicalIndicator,
  VWAP: () => VWAP,
  WMA: () => WMA,
  WSMA: () => WSMA,
  WilliamsR: () => WilliamsR,
  ZigZag: () => ZigZag,
  getAverage: () => getAverage,
  getGrid: () => getGrid,
  getMaximum: () => getMaximum,
  getMedian: () => getMedian,
  getMinimum: () => getMinimum,
  getQuartile: () => getQuartile,
  getStandardDeviation: () => getStandardDeviation,
  getStreaks: () => getStreaks,
  isFriday: () => isFriday,
  isMonday: () => isMonday,
  isSaturday: () => isSaturday,
  isSunday: () => isSunday,
  isThursday: () => isThursday,
  isTuesday: () => isTuesday,
  isWednesday: () => isWednesday,
  pushUpdate: () => pushUpdate
});
module.exports = __toCommonJS(index_exports);

// src/error/NotEnoughDataError.ts
var NotEnoughDataError = class extends Error {
  constructor(requiredAmount) {
    super(`Not enough data. A minimum of "${requiredAmount}" inputs is required to perform the computation.`);
    Object.setPrototypeOf(this, new.target.prototype);
    this.name = "NotEnoughDataError";
  }
};

// src/types/Indicator.ts
var TechnicalIndicator = class {
  result;
  getResult() {
    try {
      return this.getResultOrThrow();
    } catch {
      return null;
    }
  }
  getResultOrThrow() {
    if (this.result === void 0) {
      throw new NotEnoughDataError(this.getRequiredInputs());
    }
    return this.result;
  }
  get isStable() {
    return this.result !== void 0;
  }
  add(input) {
    return this.update(input, false);
  }
  replace(input) {
    return this.update(input, true);
  }
  updates(inputs, replace = false) {
    return inputs.map((input) => this.update(input, replace));
  }
};
var BaseIndicatorSeries = class extends TechnicalIndicator {
  previousResult;
};
var IndicatorSeries = class extends BaseIndicatorSeries {
  setResult(value, replace) {
    if (replace) {
      this.result = this.previousResult;
    }
    this.previousResult = this.result;
    return this.result = value;
  }
};

// src/exhaustion/TDS/TDS.ts
var TDS = class extends IndicatorSeries {
  closes = [];
  setupCount = 0;
  setupDirection = null;
  getRequiredInputs() {
    return 9;
  }
  update(close, replace) {
    if (replace) {
      this.closes.pop();
    }
    this.closes.push(close);
    if (this.closes.length < 5) {
      return null;
    }
    if (this.closes.length > 13) {
      this.closes.shift();
    }
    const index = this.closes.length - 1;
    const prev4 = this.closes[index - 4];
    if (close > prev4) {
      if (this.setupDirection === "bearish") {
        this.setupCount = 1;
        this.setupDirection = "bullish";
      } else {
        this.setupCount++;
        this.setupDirection = "bullish";
      }
    } else if (close < prev4) {
      if (this.setupDirection === "bullish") {
        this.setupCount = 1;
        this.setupDirection = "bearish";
      } else {
        this.setupCount++;
        this.setupDirection = "bearish";
      }
    }
    if (this.setupCount >= this.getRequiredInputs()) {
      const result = this.setupDirection === "bullish" ? 1 : -1;
      this.setupCount = 0;
      this.setupDirection = null;
      return this.setResult(result, replace);
    }
    return null;
  }
};

// src/trend/MA/MovingAverage.ts
var MovingAverage = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
  }
};

// src/util/getAverage.ts
function getAverage(values) {
  return values.length ? values.reduce((sum, x) => sum + x, 0) / values.length : 0;
}

// src/util/pushUpdate.ts
function pushUpdate(array, replace, item, maxLength) {
  if (array.length > 0 && replace === true) {
    array[array.length - 1] = item;
  } else {
    array.push(item);
  }
  if (array.length > maxLength) {
    return array.shift();
  }
  return null;
}

// src/trend/SMA/SMA.ts
var SMA = class extends MovingAverage {
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.interval);
    if (this.prices.length === this.interval) {
      return this.setResult(getAverage(this.prices), replace);
    }
    return null;
  }
};

// src/momentum/AO/AO.ts
var AO = class extends IndicatorSeries {
  constructor(shortInterval, longInterval, SmoothingIndicator = SMA) {
    super();
    this.shortInterval = shortInterval;
    this.longInterval = longInterval;
    this.short = new SmoothingIndicator(shortInterval);
    this.long = new SmoothingIndicator(longInterval);
  }
  long;
  short;
  getRequiredInputs() {
    return this.long.getRequiredInputs();
  }
  update({ low, high }, replace) {
    const medianPrice = (low + high) / 2;
    this.short.update(medianPrice, replace);
    this.long.update(medianPrice, replace);
    if (this.long.isStable) {
      return this.setResult(this.short.getResultOrThrow() - this.long.getResultOrThrow(), replace);
    }
    return null;
  }
};

// src/momentum/MOM/MOM.ts
var MOM = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
    this.historyLength = interval + 1;
    this.history = [];
  }
  history;
  historyLength;
  getRequiredInputs() {
    return this.historyLength;
  }
  update(value, replace) {
    pushUpdate(this.history, replace, value, this.historyLength);
    if (this.history.length === this.historyLength) {
      return this.setResult(value - this.history[0], replace);
    }
    return null;
  }
};

// src/momentum/AC/AC.ts
var AC = class extends IndicatorSeries {
  constructor(shortAO, longAO, signalInterval) {
    super();
    this.shortAO = shortAO;
    this.longAO = longAO;
    this.signalInterval = signalInterval;
    this.ao = new AO(shortAO, longAO);
    this.momentum = new MOM(1);
    this.signal = new SMA(signalInterval);
  }
  ao;
  momentum;
  signal;
  getRequiredInputs() {
    return this.signal.getRequiredInputs();
  }
  update(input, replace) {
    const ao = this.ao.update(input, replace);
    if (ao) {
      this.signal.update(ao, replace);
      if (this.signal.isStable) {
        const result = this.setResult(ao - this.signal.getResultOrThrow(), replace);
        this.momentum.update(result, replace);
        return result;
      }
    }
    return null;
  }
};

// src/util/getGrid.ts
function getGrid({ lower, upper, levels, tickSize, spacing }) {
  const prices = [];
  if (spacing === "arithmetic") {
    const step = (upper - lower) / (levels - 1);
    for (let i = 0; i < levels; i++) {
      prices.push(lower + step * i);
    }
  } else {
    const ratio = Math.pow(upper / lower, 1 / (levels - 1));
    for (let i = 0; i < levels; i++) {
      prices.push(lower * Math.pow(ratio, i));
    }
  }
  if (tickSize) {
    const roundToTick = (x) => Math.round(x / tickSize) * tickSize;
    return prices.map(roundToTick);
  }
  return prices;
}

// src/util/getMaximum.ts
function getMaximum(values) {
  let max = Number.MIN_SAFE_INTEGER;
  for (const value of values) {
    if (max < value) {
      max = value;
    }
  }
  return max;
}

// src/util/getMedian.ts
function getMedian(values) {
  const n = values.length;
  if (n === 0) {
    throw new Error("Cannot calculate median of empty array");
  }
  if (n % 2 === 0) {
    return (values[n / 2 - 1] + values[n / 2]) / 2;
  }
  return values[Math.floor(n / 2)];
}

// src/util/getMinimum.ts
function getMinimum(values) {
  let min = Number.MAX_SAFE_INTEGER;
  for (const value of values) {
    if (min > value) {
      min = value;
    }
  }
  return min;
}

// src/util/getQuartile.ts
function getQuartile(values, q) {
  const sorted = [...values].sort((a, b) => a - b);
  const n = sorted.length;
  const medianIndex = Math.floor(n / 2);
  if (q === 0.25) {
    return getMedian(sorted.slice(0, medianIndex));
  } else if (q === 0.75) {
    if (n % 2 === 0) {
      return getMedian(sorted.slice(medianIndex));
    }
    return getMedian(sorted.slice(medianIndex + 1));
  }
  const pos = (sorted.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  return sorted[base] + (sorted[base + 1] - sorted[base]) * rest;
}

// src/util/getStandardDeviation.ts
function getStandardDeviation(values, average) {
  const middle = average || getAverage(values);
  const squaredDifferences = values.map((value) => value - middle).map((value) => value * value);
  const averageDifference = getAverage(squaredDifferences);
  return Math.sqrt(averageDifference);
}

// src/util/getStreaks.ts
function getStreaks(prices, keepSide) {
  const streaks = [];
  let currentStreak = 0;
  function saveStreak(i) {
    const endPrice = prices[i - 1];
    const startPrice = prices[i - currentStreak - 1];
    const percentage = (endPrice - startPrice) / startPrice * 100;
    streaks.push({ length: currentStreak, percentage });
  }
  for (let i = 1; i < prices.length; i++) {
    const isUpward = keepSide === "up" && prices[i] > prices[i - 1];
    const isDownward = keepSide === "down" && prices[i] < prices[i - 1];
    if (isUpward || isDownward) {
      currentStreak++;
    } else {
      if (currentStreak > 0) {
        saveStreak(i);
      }
      currentStreak = 0;
    }
  }
  if (currentStreak > 0) {
    saveStreak(prices.length);
  }
  return streaks;
}

// src/util/getWeekday.ts
function getWeekday(timezone, date = new Date(Date.now())) {
  return new Intl.DateTimeFormat("en-US", {
    timeZone: timezone,
    weekday: "long"
  }).format(date);
}
function isMonday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Monday";
}
function isTuesday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Tuesday";
}
function isWednesday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Wednesday";
}
function isThursday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Thursday";
}
function isFriday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Friday";
}
function isSaturday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Saturday";
}
function isSunday(timezone, date = new Date(Date.now())) {
  return getWeekday(timezone, date) === "Sunday";
}

// src/volatility/MAD/MAD.ts
var MAD = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.interval);
    if (this.prices.length === this.interval) {
      const mean = getAverage(this.prices);
      let sum = 0;
      for (let i = 0; i < this.interval; i++) {
        const deviation = Math.abs(this.prices[i] - mean);
        sum += deviation;
      }
      return this.setResult(sum / this.interval, replace);
    }
    return null;
  }
  static getResultFromBatch(prices, average) {
    if (prices.length === 0) {
      return 0;
    }
    const mean = average || getAverage(prices);
    let sum = 0;
    for (let i = 0; i < prices.length; i++) {
      const deviation = Math.abs(prices[i] - mean);
      sum += deviation;
    }
    return sum / prices.length;
  }
};

// src/momentum/CCI/CCI.ts
var CCI = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
    this.sma = new SMA(this.interval);
    this.typicalPrices = [];
  }
  sma;
  typicalPrices;
  getRequiredInputs() {
    return this.sma.getRequiredInputs();
  }
  update(candle, replace) {
    const typicalPrice = this.cacheTypicalPrice(candle, replace);
    this.sma.update(typicalPrice, replace);
    if (this.sma.isStable) {
      const mean = this.sma.getResultOrThrow();
      const meanDeviation = MAD.getResultFromBatch(this.typicalPrices, mean);
      const numerator = typicalPrice - mean;
      const denominator = 0.015 * meanDeviation;
      return this.setResult(numerator / denominator, replace);
    }
    return null;
  }
  cacheTypicalPrice({ high, low, close }, replace) {
    const typicalPrice = (high + low + close) / 3;
    pushUpdate(this.typicalPrices, replace, typicalPrice, this.interval);
    return typicalPrice;
  }
};

// src/momentum/CG/CG.ts
var CG = class extends IndicatorSeries {
  constructor(interval, signalInterval) {
    super();
    this.interval = interval;
    this.signalInterval = signalInterval;
    this.signal = new SMA(signalInterval);
  }
  signal;
  prices = [];
  get isStable() {
    return this.signal.isStable;
  }
  getRequiredInputs() {
    return this.signal.getRequiredInputs();
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.interval);
    let nominator = 0;
    let denominator = 0;
    for (let i = 0; i < this.prices.length; ++i) {
      const price2 = this.prices[i];
      nominator = nominator + price2 * (i + 1);
      denominator = denominator + price2;
    }
    const cg = denominator > 0 ? nominator / denominator : 0;
    this.signal.update(cg, replace);
    if (this.signal.isStable) {
      return this.setResult(cg, replace);
    }
    return null;
  }
};

// src/momentum/MACD/MACD.ts
var MACD = class extends TechnicalIndicator {
  constructor(short, long, signal) {
    super();
    this.short = short;
    this.long = long;
    this.signal = signal;
  }
  prices = [];
  getRequiredInputs() {
    return this.long.getRequiredInputs();
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.long.interval);
    const short = this.short.update(price, replace);
    const long = this.long.update(price, replace);
    if (this.prices.length === this.long.interval) {
      const macd = short - long;
      const signal = this.signal.update(macd, replace);
      return this.result = {
        histogram: macd - signal,
        macd,
        signal
      };
    }
    return null;
  }
};

// src/momentum/OBV/OBV.ts
var OBV = class extends IndicatorSeries {
  candles = [];
  getRequiredInputs() {
    return 2;
  }
  update(candle, replace) {
    pushUpdate(this.candles, replace, candle, 2);
    if (this.candles.length === 1) {
      return null;
    }
    const prevCandle = this.candles[this.candles.length - 2];
    const prevPrice = prevCandle.close;
    const prevResult = this.result ?? 0;
    const currentPrice = candle.close;
    const nextResult = currentPrice > prevPrice ? candle.volume : currentPrice < prevPrice ? -candle.volume : 0;
    return this.setResult(prevResult + nextResult, false);
  }
};

// src/momentum/REI/REI.ts
var REI = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  highs = [];
  lows = [];
  closes = [];
  getRequiredInputs() {
    return this.interval + 8;
  }
  calculateN(j) {
    if (this.highs[j - 2] < this.closes[j - 7] && this.highs[j - 2] < this.closes[j - 8] && this.highs[j] < this.highs[j - 5] && this.highs[j] < this.highs[j - 6]) {
      return 0;
    }
    return 1;
  }
  calculateM(j) {
    if (this.lows[j - 2] > this.closes[j - 7] && this.lows[j - 2] > this.closes[j - 8] && this.lows[j] > this.lows[j - 5] && this.lows[j] > this.lows[j - 6]) {
      return 0;
    }
    return 1;
  }
  update(candle, replace) {
    if (replace) {
      this.highs.pop();
      this.lows.pop();
      this.closes.pop();
    }
    this.highs.push(candle.high);
    this.lows.push(candle.low);
    this.closes.push(candle.close);
    if (this.highs.length < this.getRequiredInputs()) {
      return null;
    }
    let subValueSum = 0;
    let absValueSum = 0;
    const limitIndex = this.highs.length - 1;
    for (let j = limitIndex; j > this.interval; j--) {
      const diffHighs = this.highs[j] - this.highs[j - 2];
      const diffLows = this.lows[j] - this.lows[j - 2];
      const n = this.calculateN(j);
      const m = this.calculateM(j);
      const s = diffHighs + diffLows;
      const subValue = n * m * s;
      const absDailyValue = Math.abs(diffHighs) + Math.abs(diffLows);
      subValueSum += subValue;
      absValueSum += absDailyValue;
    }
    if (absValueSum === 0) {
      return this.setResult(0, replace);
    }
    const rei = subValueSum / absValueSum * 100;
    return this.setResult(rei, replace);
  }
};

// src/momentum/ROC/ROC.ts
var ROC = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    const comparePrice = pushUpdate(this.prices, replace, price, this.interval);
    if (comparePrice) {
      return this.setResult((price - comparePrice) / comparePrice, replace);
    }
    return null;
  }
};

// src/trend/WSMA/WSMA.ts
var WSMA = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
    this.indicator = new SMA(interval);
    this.smoothingFactor = 1 / this.interval;
  }
  indicator;
  smoothingFactor;
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    const sma = this.indicator.update(price, replace);
    if (replace && this.previousResult !== void 0) {
      const smoothed = (price - this.previousResult) * this.smoothingFactor;
      return this.setResult(smoothed + this.previousResult, replace);
    } else if (!replace && this.result !== void 0) {
      const smoothed = (price - this.result) * this.smoothingFactor;
      return this.setResult(smoothed + this.result, replace);
    } else if (this.result === void 0 && sma !== null) {
      return this.setResult(sma, replace);
    }
    return null;
  }
};

// src/momentum/RSI/RSI.ts
var RSI = class extends IndicatorSeries {
  constructor(interval, SmoothingIndicator = WSMA) {
    super();
    this.interval = interval;
    this.avgGain = new SmoothingIndicator(this.interval);
    this.avgLoss = new SmoothingIndicator(this.interval);
  }
  previousPrices = [];
  avgGain;
  avgLoss;
  maxValue = 100;
  getRequiredInputs() {
    return this.avgGain.getRequiredInputs();
  }
  update(price, replace) {
    pushUpdate(this.previousPrices, replace, price, this.interval);
    if (this.previousPrices.length < 2) {
      return null;
    }
    const currentPrice = price;
    const previousPrice = this.previousPrices[this.previousPrices.length - 2];
    if (currentPrice > previousPrice) {
      this.avgLoss.update(0, replace);
      this.avgGain.update(price - previousPrice, replace);
    } else {
      this.avgLoss.update(previousPrice - currentPrice, replace);
      this.avgGain.update(0, replace);
    }
    if (this.avgGain.isStable) {
      const avgLoss = this.avgLoss.getResultOrThrow();
      if (avgLoss === 0) {
        return this.setResult(100, replace);
      }
      const relativeStrength = this.avgGain.getResultOrThrow() / avgLoss;
      return this.setResult(this.maxValue - this.maxValue / (relativeStrength + 1), replace);
    }
    return null;
  }
};

// src/momentum/STOCH/StochasticOscillator.ts
var StochasticOscillator = class extends TechnicalIndicator {
  /**
   * @param n The %k period
   * @param m The %k slowing period
   * @param p The %d period
   */
  constructor(n, m, p) {
    super();
    this.n = n;
    this.m = m;
    this.p = p;
    this.periodM = new SMA(m);
    this.periodP = new SMA(p);
  }
  candles = [];
  periodM;
  periodP;
  getRequiredInputs() {
    return this.n + this.p + 1;
  }
  update(candle, replace) {
    pushUpdate(this.candles, replace, candle, this.n);
    if (this.candles.length === this.n) {
      const highest = Math.max(...this.candles.map((candle2) => candle2.high));
      const lowest = Math.min(...this.candles.map((candle2) => candle2.low));
      const divisor = highest - lowest;
      let fastK = (candle.close - lowest) * 100;
      fastK = fastK / (divisor === 0 ? 1 : divisor);
      const stochK = this.periodM.update(fastK, replace);
      const stochD = stochK && this.periodP.update(stochK, replace);
      if (stochK !== null && stochD !== null) {
        return this.result = {
          stochD,
          stochK
        };
      }
    }
    return null;
  }
};

// src/types/Period.ts
var Period = class extends TechnicalIndicator {
  constructor(interval) {
    super();
    this.interval = interval;
    this.values = [];
  }
  values;
  /** Highest return value during the current period. */
  _highest;
  /** Lowest return value during the current period. */
  _lowest;
  get highest() {
    return this._highest;
  }
  get lowest() {
    return this._lowest;
  }
  getRequiredInputs() {
    return this.interval;
  }
  update(value, replace) {
    pushUpdate(this.values, replace, value, this.interval);
    if (this.values.length === this.interval) {
      this._lowest = Math.min(...this.values);
      this._highest = Math.max(...this.values);
      return this.result = {
        highest: this._highest,
        lowest: this._lowest
      };
    }
    return null;
  }
};

// src/momentum/STOCHRSI/StochasticRSI.ts
var StochasticRSI = class extends IndicatorSeries {
  constructor(interval, SmoothingRSI = WSMA, smoothing = {
    d: new SMA(3),
    k: new SMA(3)
  }) {
    super();
    this.interval = interval;
    this.smoothing = smoothing;
    this.period = new Period(interval);
    this.rsi = new RSI(interval, SmoothingRSI);
  }
  period;
  rsi;
  getRequiredInputs() {
    return this.rsi.getRequiredInputs() + this.period.getRequiredInputs();
  }
  update(price, replace) {
    const rsiResult = this.rsi.update(price, replace);
    if (rsiResult) {
      const periodResult = this.period.update(rsiResult, replace);
      if (periodResult) {
        const min = periodResult.lowest;
        const max = periodResult.highest;
        const denominator = max - min;
        if (denominator === 0) {
          return this.setResult(100, replace);
        }
        const numerator = rsiResult - min;
        const stochRSI = numerator / denominator;
        const k = this.smoothing.k.update(stochRSI, replace);
        if (k) {
          this.smoothing.d.update(k, replace);
        }
        return this.setResult(stochRSI, replace);
      }
    }
    return null;
  }
};

// src/momentum/WILLR/WilliamsR.ts
var WilliamsR = class extends TechnicalIndicator {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  candles = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(candle, replace) {
    pushUpdate(this.candles, replace, candle, this.interval);
    if (this.candles.length === this.interval) {
      let highest = this.candles[0].high;
      let lowest = this.candles[0].low;
      for (let i = 1; i < this.candles.length; i++) {
        if (this.candles[i].high > highest) {
          highest = this.candles[i].high;
        }
        if (this.candles[i].low < lowest) {
          lowest = this.candles[i].low;
        }
      }
      const divisor = highest - lowest;
      if (divisor === 0) {
        return this.result = -100;
      }
      const willR = (highest - candle.close) / divisor * -100;
      return this.result = willR;
    }
    return null;
  }
};

// src/volatility/TR/TR.ts
var TR = class extends IndicatorSeries {
  previousCandle;
  twoPreviousCandle;
  getRequiredInputs() {
    return 2;
  }
  update(candle, replace) {
    const { high, low } = candle;
    const highLow = high - low;
    if (this.previousCandle && replace) {
      this.previousCandle = this.twoPreviousCandle;
    }
    if (this.previousCandle) {
      const highClose = Math.abs(high - this.previousCandle.close);
      const lowClose = Math.abs(low - this.previousCandle.close);
      this.twoPreviousCandle = this.previousCandle;
      this.previousCandle = candle;
      return this.setResult(Math.max(highLow, highClose, lowClose), replace);
    }
    this.twoPreviousCandle = this.previousCandle;
    this.previousCandle = candle;
    return this.setResult(highLow, replace);
  }
};

// src/volatility/ATR/ATR.ts
var ATR = class extends IndicatorSeries {
  constructor(interval, SmoothingIndicator = WSMA) {
    super();
    this.interval = interval;
    this.tr = new TR();
    this.smoothing = new SmoothingIndicator(interval);
  }
  tr;
  smoothing;
  getRequiredInputs() {
    return this.smoothing.getRequiredInputs();
  }
  update(candle, replace) {
    const trueRange = this.tr.update(candle, replace);
    this.smoothing.update(trueRange, replace);
    if (this.smoothing.isStable) {
      return this.setResult(this.smoothing.getResultOrThrow(), replace);
    }
    return null;
  }
};

// src/trend/DX/DX.ts
var DX = class extends IndicatorSeries {
  constructor(interval, SmoothingIndicator = WSMA) {
    super();
    this.interval = interval;
    this.atr = new ATR(this.interval, SmoothingIndicator);
    this.movesDown = new SmoothingIndicator(this.interval);
    this.movesUp = new SmoothingIndicator(this.interval);
  }
  movesUp;
  movesDown;
  previousCandle;
  secondLastCandle;
  atr;
  mdi;
  pdi;
  updateState(candle, pdm, mdm, replace) {
    this.atr.update(candle, replace);
    this.movesUp.update(pdm, replace);
    this.movesDown.update(mdm, replace);
    if (this.previousCandle) {
      this.secondLastCandle = this.previousCandle;
    }
    this.previousCandle = candle;
  }
  getRequiredInputs() {
    return this.movesUp.getRequiredInputs();
  }
  update(candle, replace) {
    if (!this.previousCandle) {
      this.updateState(candle, 0, 0, replace);
      return null;
    }
    if (this.secondLastCandle && replace) {
      this.previousCandle = this.secondLastCandle;
    }
    const currentHigh = candle.high;
    const previousHigh = this.previousCandle.high;
    const currentLow = candle.low;
    const previousLow = this.previousCandle.low;
    const higherHigh = currentHigh - previousHigh;
    const lowerLow = previousLow - currentLow;
    const noHigherHighs = higherHigh < 0;
    const lowsRise = higherHigh < lowerLow;
    const pdm = noHigherHighs || lowsRise ? 0 : higherHigh;
    const noLowerLows = lowerLow < 0;
    const highsRise = lowerLow < higherHigh;
    const mdm = noLowerLows || highsRise ? 0 : lowerLow;
    this.updateState(candle, pdm, mdm, replace);
    if (this.movesUp.isStable) {
      this.pdi = this.movesUp.getResultOrThrow() / this.atr.getResultOrThrow();
      this.mdi = this.movesDown.getResultOrThrow() / this.atr.getResultOrThrow();
      const dmDiff = Math.abs(this.pdi - this.mdi);
      const dmSum = this.pdi + this.mdi;
      if (dmSum === 0) {
        return this.setResult(0, replace);
      }
      return this.setResult(dmDiff / dmSum * 100, replace);
    }
    return null;
  }
};

// src/trend/ADX/ADX.ts
var ADX = class extends IndicatorSeries {
  constructor(interval, SmoothingIndicator = WSMA) {
    super();
    this.interval = interval;
    this.smoothed = new SmoothingIndicator(this.interval);
    this.dx = new DX(interval, SmoothingIndicator);
  }
  dx;
  smoothed;
  get mdi() {
    return this.dx.mdi;
  }
  get pdi() {
    return this.dx.pdi;
  }
  getRequiredInputs() {
    return this.interval * 2 - 1;
  }
  update(candle, replace) {
    const result = this.dx.update(candle, replace);
    if (result !== null) {
      this.smoothed.update(result, replace);
    }
    if (this.smoothed.isStable) {
      return this.setResult(this.smoothed.getResultOrThrow(), replace);
    }
    return null;
  }
};

// src/trend/EMA/EMA.ts
var EMA = class extends MovingAverage {
  constructor(interval) {
    super(interval);
    this.interval = interval;
    this.weightFactor = 2 / (this.interval + 1);
  }
  pricesCounter = 0;
  weightFactor;
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    if (!replace) {
      this.pricesCounter++;
    } else if (replace && this.pricesCounter === 0) {
      this.pricesCounter++;
    }
    if (replace && this.previousResult !== void 0) {
      return this.setResult(price * this.weightFactor + this.previousResult * (1 - this.weightFactor), replace);
    }
    return this.setResult(
      price * this.weightFactor + (this.result !== void 0 ? this.result : price) * (1 - this.weightFactor),
      replace
    );
  }
  getResultOrThrow() {
    if (this.pricesCounter < this.interval) {
      throw new NotEnoughDataError(this.getRequiredInputs());
    }
    return this.result;
  }
  get isStable() {
    try {
      this.getResultOrThrow();
      return true;
    } catch {
      return false;
    }
  }
};

// src/trend/DEMA/DEMA.ts
var DEMA = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
    this.inner = new EMA(interval);
    this.outer = new EMA(interval);
  }
  inner;
  outer;
  getRequiredInputs() {
    return this.outer.getRequiredInputs();
  }
  update(price, replace) {
    const innerResult = this.inner.update(price, replace);
    const outerResult = this.outer.update(innerResult, replace);
    return this.setResult(innerResult * 2 - outerResult, replace);
  }
  get isStable() {
    return this.outer.isStable;
  }
};

// src/trend/DMA/DMA.ts
var DMA = class extends TechnicalIndicator {
  short;
  long;
  constructor(short, long, SmoothingIndicator = SMA) {
    super();
    this.short = new SmoothingIndicator(short);
    this.long = new SmoothingIndicator(long);
  }
  get isStable() {
    return this.long.isStable;
  }
  getRequiredInputs() {
    return this.long.getRequiredInputs();
  }
  update(price, replace) {
    this.short.update(price, replace);
    this.long.update(price, replace);
    if (this.isStable) {
      return this.result = {
        long: this.long.getResultOrThrow(),
        short: this.short.getResultOrThrow()
      };
    }
    return null;
  }
};

// src/trend/LINREG/LinearRegression.ts
var LinearRegression = class extends TechnicalIndicator {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  calculateRegression(prices) {
    const n = prices.length;
    const isPerfectLinearTrend = prices.every((price, i) => {
      if (i === 0) {
        return true;
      }
      return Math.abs(price - prices[i - 1] - 1) < 1e-10;
    });
    if (isPerfectLinearTrend) {
      const slope2 = 1;
      const intercept2 = prices[0] - slope2;
      const nextX = n;
      const prediction2 = slope2 * nextX + intercept2;
      return { intercept: intercept2, prediction: prediction2, slope: slope2 };
    }
    const sumX = (n - 1) * n / 2;
    const sumY = prices.reduce((a, b) => a + b, 0);
    let sumXY = 0;
    let sumXX = 0;
    for (let i = 0; i < n; i++) {
      sumXY += i * prices[i];
      sumXX += i * i;
    }
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    const prediction = slope * n + intercept;
    return {
      intercept,
      prediction,
      slope
    };
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.interval);
    if (this.prices.length < this.interval) {
      return null;
    }
    return this.result = this.calculateRegression(this.prices);
  }
  get isStable() {
    try {
      this.getResultOrThrow();
      return true;
    } catch {
      return false;
    }
  }
};

// src/trend/PSAR/PSAR.ts
var PSAR = class extends IndicatorSeries {
  accelerationStep;
  accelerationMax;
  acceleration = 0;
  extreme = null;
  lastSar = null;
  isLong = null;
  previousCandle = null;
  prePreviousCandle = null;
  constructor(config) {
    super();
    this.accelerationStep = config.accelerationStep;
    this.accelerationMax = config.accelerationMax;
    if (this.accelerationStep <= 0) {
      throw new Error("Acceleration step must be greater than 0");
    }
    if (this.accelerationMax <= this.accelerationStep) {
      throw new Error("Acceleration max must be greater than acceleration step");
    }
  }
  get isStable() {
    return this.lastSar !== null;
  }
  getRequiredInputs() {
    return 2;
  }
  update(candle, replace) {
    const { high, low } = candle;
    const notEnoughData = !this.previousCandle || this.lastSar === null;
    if (replace && notEnoughData) {
      this.previousCandle = candle;
      return null;
    }
    if (!this.previousCandle) {
      this.previousCandle = candle;
      return null;
    }
    if (this.lastSar === null) {
      const currentMidpoint = (high + low) / 2;
      const previousMidpoint = (this.previousCandle.high + this.previousCandle.low) / 2;
      this.isLong = currentMidpoint >= previousMidpoint;
      if (this.isLong) {
        this.extreme = high;
        this.lastSar = this.previousCandle.low;
      } else {
        this.extreme = low;
        this.lastSar = this.previousCandle.high;
      }
      this.acceleration = this.accelerationStep;
      this.prePreviousCandle = this.previousCandle;
      this.previousCandle = candle;
      return this.setResult(this.lastSar, replace);
    }
    let sar = (this.extreme - this.lastSar) * this.acceleration + this.lastSar;
    if (this.isLong) {
      const hasPrevPrev = this.prePreviousCandle != null;
      if (hasPrevPrev && low < sar) {
        if (this.prePreviousCandle.low < sar) {
          sar = this.prePreviousCandle.low;
        }
        sar = this.previousCandle.low < sar ? this.previousCandle.low : sar;
      } else if (this.previousCandle.low < sar) {
        sar = this.previousCandle.low;
      }
      if (high > this.extreme) {
        this.extreme = high;
        if (this.acceleration < this.accelerationMax) {
          this.acceleration += this.accelerationStep;
          if (this.acceleration > this.accelerationMax) {
            this.acceleration = this.accelerationMax;
          }
        }
      }
      if (low < sar) {
        this.isLong = false;
        sar = this.extreme;
        this.extreme = low;
        this.acceleration = this.accelerationStep;
      }
    } else {
      const hasPrevPrev = this.prePreviousCandle != null;
      if (hasPrevPrev && high > sar) {
        if (this.prePreviousCandle.high > sar) {
          sar = this.prePreviousCandle.high;
        }
        sar = this.previousCandle.high > sar ? this.previousCandle.high : sar;
      } else if (this.previousCandle.high > sar) {
        sar = this.previousCandle.high;
      }
      if (low < this.extreme) {
        this.extreme = low;
        this.acceleration += this.accelerationStep;
        if (this.acceleration > this.accelerationMax) {
          this.acceleration = this.accelerationMax;
        }
      }
      if (high > sar) {
        this.isLong = true;
        sar = this.extreme;
        this.extreme = high;
        this.acceleration = this.accelerationStep;
        if (sar >= low) {
          sar = low - 0.01;
        }
      }
    }
    this.lastSar = sar;
    this.prePreviousCandle = this.previousCandle;
    this.previousCandle = candle;
    return this.setResult(sar, replace);
  }
  getResultOrThrow() {
    return super.getResultOrThrow();
  }
};

// src/trend/RMA/RMA.ts
var RMA = class extends MovingAverage {
  constructor(interval) {
    super(interval);
    this.interval = interval;
    this.weightFactor = 1 / this.interval;
  }
  pricesCounter = 0;
  weightFactor;
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    if (!replace) {
      this.pricesCounter++;
    } else if (replace && this.pricesCounter === 0) {
      this.pricesCounter++;
    }
    if (replace && this.previousResult !== void 0) {
      return this.setResult(price * this.weightFactor + this.previousResult * (1 - this.weightFactor), replace);
    }
    return this.setResult(
      price * this.weightFactor + (this.result !== void 0 ? this.result : price) * (1 - this.weightFactor),
      replace
    );
  }
  getResultOrThrow() {
    if (this.pricesCounter < this.interval) {
      throw new NotEnoughDataError(this.getRequiredInputs());
    }
    return this.result;
  }
  get isStable() {
    try {
      this.getResultOrThrow();
      return true;
    } catch {
      return false;
    }
  }
};

// src/trend/SMA15/SMA15.ts
var SMA15 = class _SMA15 extends MovingAverage {
  prices = [];
  static WEIGHTS = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3];
  static WEIGHT_SUM = 320;
  getRequiredInputs() {
    return _SMA15.WEIGHTS.length;
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.getRequiredInputs());
    if (this.prices.length === this.getRequiredInputs()) {
      let weightedPricesSum = 0;
      for (let i = 0; i < this.getRequiredInputs(); i++) {
        const weightedPrice = this.prices[i] * _SMA15.WEIGHTS[i];
        weightedPricesSum += weightedPrice;
      }
      const weightedAverage = weightedPricesSum / _SMA15.WEIGHT_SUM;
      return this.setResult(weightedAverage, replace);
    }
    return null;
  }
};

// src/trend/VWAP/VWAP.ts
var VWAP = class extends IndicatorSeries {
  cumulativeTypicalPriceVolume = 0;
  cumulativeVolume = 0;
  lastCandle = null;
  constructor() {
    super();
  }
  calculateTypicalPriceVolume(data) {
    const hlc3 = (data.high + data.low + data.close) / 3;
    return hlc3 * data.volume;
  }
  getRequiredInputs() {
    return 2;
  }
  update(candle, replace) {
    if (candle.volume === 0) {
      return null;
    }
    if (replace && this.lastCandle !== null) {
      const lastTypicalPriceVolume = this.calculateTypicalPriceVolume(this.lastCandle);
      this.cumulativeTypicalPriceVolume = this.cumulativeTypicalPriceVolume - lastTypicalPriceVolume;
      this.cumulativeVolume = this.cumulativeVolume - this.lastCandle.volume;
    }
    this.lastCandle = candle;
    const typicalPriceVolume = this.calculateTypicalPriceVolume(candle);
    this.cumulativeTypicalPriceVolume = this.cumulativeTypicalPriceVolume + typicalPriceVolume;
    this.cumulativeVolume = this.cumulativeVolume + candle.volume;
    const vwap = this.cumulativeTypicalPriceVolume / this.cumulativeVolume;
    return this.setResult(vwap, replace);
  }
};

// src/trend/WMA/WMA.ts
var WMA = class extends MovingAverage {
  constructor(interval) {
    super(interval);
    this.interval = interval;
  }
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    pushUpdate(this.prices, replace, price, this.interval);
    if (this.prices.length === this.interval) {
      const weightedPricesSum = this.prices.reduce((acc, price2, index) => {
        const weightedPrice = price2 * (index + 1);
        return acc + weightedPrice;
      }, 0);
      const weightBase = this.interval * (this.interval + 1) / 2;
      const weightedMa = weightedPricesSum / weightBase;
      return this.setResult(weightedMa, replace);
    }
    return null;
  }
};

// src/trend/ZIGZAG/ZigZag.ts
var ZigZag = class extends IndicatorSeries {
  deviation;
  isUp = false;
  highestExtreme = null;
  lowestExtreme = null;
  constructor(config) {
    super();
    this.deviation = config.deviation;
  }
  getRequiredInputs() {
    return 1;
  }
  update(candle, replace) {
    const low = candle.low;
    const high = candle.high;
    if (this.lowestExtreme === null) {
      this.lowestExtreme = low;
    }
    if (this.highestExtreme === null) {
      this.highestExtreme = high;
    }
    if (this.isUp) {
      const uptrendReversal = this.lowestExtreme + (this.highestExtreme - this.lowestExtreme) * (100 - this.deviation) / 100;
      if (high > this.highestExtreme) {
        this.highestExtreme = high;
      } else if (low < uptrendReversal) {
        this.isUp = false;
        this.lowestExtreme = low;
        return this.setResult(this.highestExtreme, replace);
      }
    } else {
      const downtrendReversal = low + (this.highestExtreme - low) * this.deviation / 100;
      if (low < this.lowestExtreme) {
        this.lowestExtreme = low;
      } else if (high > downtrendReversal) {
        this.isUp = true;
        this.highestExtreme = high;
        return this.setResult(this.lowestExtreme, replace);
      }
    }
    return null;
  }
};

// src/volatility/ABANDS/AccelerationBands.ts
var AccelerationBands = class extends TechnicalIndicator {
  constructor(interval, width, SmoothingIndicator = SMA) {
    super();
    this.interval = interval;
    this.width = width;
    this.lowerBand = new SmoothingIndicator(interval);
    this.middleBand = new SmoothingIndicator(interval);
    this.upperBand = new SmoothingIndicator(interval);
  }
  lowerBand;
  middleBand;
  upperBand;
  getRequiredInputs() {
    return this.middleBand.getRequiredInputs();
  }
  update({ high, low, close }, replace) {
    const highPlusLow = high + low;
    const coefficient = highPlusLow === 0 ? 0 : (high - low) / highPlusLow * this.width;
    this.lowerBand.update(low * (1 - coefficient), replace);
    this.middleBand.update(close, replace);
    this.upperBand.update(high * (1 + coefficient), replace);
    if (this.isStable) {
      return this.result = {
        lower: this.lowerBand.getResultOrThrow(),
        middle: this.middleBand.getResultOrThrow(),
        upper: this.upperBand.getResultOrThrow()
      };
    }
    return null;
  }
  get isStable() {
    return this.middleBand.isStable;
  }
};

// src/volatility/BBANDS/BollingerBands.ts
var BollingerBands = class extends TechnicalIndicator {
  constructor(interval, deviationMultiplier = 2) {
    super();
    this.interval = interval;
    this.deviationMultiplier = deviationMultiplier;
  }
  prices = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(price, replace) {
    const dropOut = pushUpdate(this.prices, replace, price, this.interval);
    if (dropOut) {
      const middle = getAverage(this.prices);
      const standardDeviation = getStandardDeviation(this.prices, middle);
      return this.result = {
        lower: middle - standardDeviation * this.deviationMultiplier,
        middle,
        upper: middle + standardDeviation * this.deviationMultiplier
      };
    }
    return null;
  }
};

// src/volatility/BBW/BollingerBandsWidth.ts
var BollingerBandsWidth = class extends IndicatorSeries {
  constructor(bollingerBands) {
    super();
    this.bollingerBands = bollingerBands;
  }
  getRequiredInputs() {
    return this.bollingerBands.getRequiredInputs();
  }
  update(price, replace) {
    const result = this.bollingerBands.update(price, replace);
    if (result) {
      return this.setResult((result.upper - result.lower) / result.middle, replace);
    }
    return null;
  }
};

// src/volatility/IQR/IQR.ts
var IQR = class extends IndicatorSeries {
  constructor(interval) {
    super();
    this.interval = interval;
  }
  values = [];
  getRequiredInputs() {
    return this.interval;
  }
  update(value, replace) {
    if (replace) {
      this.values.pop();
    }
    this.values.push(value);
    if (this.values.length > this.interval) {
      this.values.shift();
    }
    if (this.values.length < this.interval) {
      return null;
    }
    const q1 = getQuartile(this.values, 0.25);
    const q3 = getQuartile(this.values, 0.75);
    return this.setResult(q3 - q1, replace);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AC,
  ADX,
  AO,
  ATR,
  AccelerationBands,
  BaseIndicatorSeries,
  BollingerBands,
  BollingerBandsWidth,
  CCI,
  CG,
  DEMA,
  DMA,
  DX,
  EMA,
  IQR,
  IndicatorSeries,
  LinearRegression,
  MACD,
  MAD,
  MOM,
  NotEnoughDataError,
  OBV,
  PSAR,
  Period,
  REI,
  RMA,
  ROC,
  RSI,
  SMA,
  SMA15,
  StochasticOscillator,
  StochasticRSI,
  TDS,
  TR,
  TechnicalIndicator,
  VWAP,
  WMA,
  WSMA,
  WilliamsR,
  ZigZag,
  getAverage,
  getGrid,
  getMaximum,
  getMedian,
  getMinimum,
  getQuartile,
  getStandardDeviation,
  getStreaks,
  isFriday,
  isMonday,
  isSaturday,
  isSunday,
  isThursday,
  isTuesday,
  isWednesday,
  pushUpdate
});
